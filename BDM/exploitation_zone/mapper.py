from pyspark.sql import SparkSession
from pyspark.conf import SparkConf
from monetdb_reader import DBReader
from pathlib import Path
from neo4j_connector import Neo4jConnector
from pyspark.sql.functions import *

import os
import sys

sys.path.insert(0, os.path.dirname(Path(__file__).parent.absolute()))
import configs.common as common

db_reader = DBReader()
driver_path = db_reader.get_driver_path()

# hdfs_host = common.hdfs['host_path']
branch_id = common.global_params['branch_id']

conf = SparkConf()
conf.set("spark.jars", driver_path)
conf.set("spark.sql.execution.arrow.pyspark.enabled", "true")

spark = SparkSession.builder.config(conf=conf).master("local").appName(common.spark['appName']).getOrCreate()

## Products query
products_q = '''select product_id, label, type 
                        from client.products'''

products = db_reader.read_table( spark,products_q)

## Stocks query
stocks_q = '''select stock_id, expiry_date 
                        from client.stocks where in_shelf=True''' ##first fix the db schema .. then add the in_shelf=true condition

stocks = db_reader.read_table( spark, stocks_q)

## Product prices query
product_prices_q = '''select sid, product_id, selling_price, stock_id 
                        from client.product_prices'''

product_prices = db_reader.read_table(spark, product_prices_q)

## Sales query
sales_details_q = '''select invoice_id, item_id 
                        from client.sales'''

sales_details = db_reader.read_table(spark, sales_details_q)

sales_details = sales_details.join(product_prices,product_prices.sid == sales_details.item_id,"inner")

prep_invoices = sales_details.groupBy(col("invoice_id")).agg(collect_list(col("product_id")).alias('products'))

## Inventory query

latest_inv_dets_q = '''select stock_id, quantity
                from (
                select stock_id, date, quantity,
                        row_number() over (partition by stock_id order by date desc) as rn
                from client.inventory 
                ) agg
                where agg.rn = 1'''

inventory = db_reader.read_table(spark, latest_inv_dets_q)

product_quantity = product_prices.join(inventory, inventory.stock_id == product_prices.stock_id, "inner")


graphdb = Neo4jConnector()

def create_product_entity(product): ## check if product exists before creating
        
        conn = graphdb.get_conn()
        with conn.session() as session:
            session.run("MERGE (p:Product {id: $id,  label: $label, type: $type})", id=product['product_id'], label = product['label'], type= product['type'])
        graphdb.close_conn()

def create_stock_entity(stock):   ## should we delete all before creating

        conn = graphdb.get_conn()
        with conn.session() as session:
            session.run("CREATE (s:Stock {id: $id, expiry_date: $expiry })", id=stock['stock_id'], expiry = stock['expiry_date'])
        graphdb.close_conn()

def create_propduct_to_stock_relation(prod_stock):

        conn = graphdb.get_conn()
        with conn.session() as session:
                session.run("""
                                MATCH (p1:Product {id: $product_id})
                                MATCH (s:Stock {id: $stock_id})
                                MERGE (p1)-[r:in_stock]->(s)
                                ON CREATE SET r.quantity = $qty, r.sid = $sid, r.selling_price = $selling_price
                                ON MATCH SET r.quantity = $qty, r.selling_price = $selling_price 
                                """, product_id=prod_stock['product_id'], stock_id=prod_stock['stock_id'],qty=prod_stock['quantity'],selling_price=prod_stock['selling_price'],sid=prod_stock['sid'])
                # session.run ("""
                #                 MATCH (p:Product {id: $product_id})
                #                 SET p.in_stock = 1
                # """, product_id=prod_stock['product_id'])
        # Close the Neo4j driver
        graphdb.close_conn()

def create_propduct_to_product_network(inv):
        
        conn = graphdb.get_conn()
        products = inv['products']

        for i in range(len(products)):
                product_a = products[i]
                with conn.session() as session:
                # Loop over subsequent products and create relationships
                        for j in range(i + 1, len(products)):
                                product_b = products[j]
                                session.run("""
                                MATCH (p1:Product {id: $product_a})
                                MATCH (p2:Product {id: $product_b})
                                WHERE p1.id <> p2.id
                                MERGE (p1)-[r:purchased_with]-(p2)
                                ON CREATE SET r.count = 1
                                ON MATCH SET r.count = r.count + 1 
                                """, product_a=product_a, product_b=product_b)
        # Close the Neo4j driver
        graphdb.close_conn()

def create_community_detection_subgraphs():
        conn = graphdb.get_conn()
        with conn.session() as session:
                session.run("""
                                CALL gds.graph.project('ProductsBoughtTogether', 
                                'Product',
                                {
                                        purchased_with: {
                                                orientation: 'UNDIRECTED',
                                                properties: ['count']
                                        }
                                });
                        """)
                session.run("""
                                CALL gds.louvain.stream('ProductsBoughtTogether', {
                                        relationshipWeightProperty: 'count',
                                        includeIntermediateCommunities: True
                                }) 
                                YIELD nodeId, communityId, intermediateCommunityIds as intComs
                                WITH gds.util.asNode(nodeId).id AS Name, gds.util.asNode(nodeId).label AS Label, communityId, intComs
                                WITH  Name, Label,communityId, intComs[0] as intermediateCom 
                                MATCH (p:Product)
                                WHERE p.id = Name
                                SET p.communityId = communityId , p.intermediateComId = intermediateCom
                                RETURN p
                        """)
                session.run("""
                                CALL gds.graph.project('ProductCommunities', 
                                {
                                        Product:
                                        {
                                                properties:['communityId','intermediateComId']
                                        }
                                },
                                {
                                        purchased_with: {
                                                orientation: 'UNDIRECTED',
                                                properties: ['count']
                                        }
                                });
                        """)
        # Close the Neo4j driver
        graphdb.close_conn()         

products.foreach(create_product_entity)
stocks.foreach(create_stock_entity)
product_quantity.foreach(create_propduct_to_stock_relation)
prep_invoices.foreach(create_propduct_to_product_network)
create_community_detection_subgraphs()

